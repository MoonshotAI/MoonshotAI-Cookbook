// Code generated by defc, DO NOT EDIT.

package main

import (
	"bufio"
	"bytes"
	"context"
	"fmt"
	"io"
	"net/http"
	"net/textproto"
	"reflect"
	"sync"
	"text/template"
	"time"
)

const (
	CallerListModels                 = "ListModels"
	CallerEstimateTokenCount         = "EstimateTokenCount"
	CallerCheckBalance               = "CheckBalance"
	CallerCreateChatCompletion       = "CreateChatCompletion"
	CallerCreateChatCompletionStream = "CreateChatCompletionStream"
	CallerCreateContextCache         = "CreateContextCache"
	CallerRetrieveContextCache       = "RetrieveContextCache"
	CallerDeleteContextCache         = "DeleteContextCache"
	CallerRetrieveContextCacheTag    = "RetrieveContextCacheTag"
	CallerUploadFile                 = "UploadFile"
	CallerListFiles                  = "ListFiles"
	CallerDeleteFile                 = "DeleteFile"
	CallerRetrieveFileContent        = "RetrieveFileContent"
)

func NewClient[C Caller](Client C) Client[C] {
	return &implClient[C]{__Client: Client}
}

type implClient[C Caller] struct {
	__Client C
}

var (
	addrTmplListModels                   = template.Must(template.New("AddressListModels").Funcs(template.FuncMap{"get_cache_options": getCacheOptions}).Parse("{{ $.Client.BaseUrl }}/models"))
	headerTmplListModels                 = template.Must(template.New("HeaderListModels").Funcs(template.FuncMap{"get_cache_options": getCacheOptions}).Parse("Authorization: Bearer {{ $.Client.Key }}\r\n\r\n"))
	addrTmplEstimateTokenCount           = template.Must(template.New("AddressEstimateTokenCount").Funcs(template.FuncMap{"get_cache_options": getCacheOptions}).Parse("{{ $.Client.BaseUrl }}/tokenizers/estimate-token-count"))
	headerTmplEstimateTokenCount         = template.Must(template.New("HeaderEstimateTokenCount").Funcs(template.FuncMap{"get_cache_options": getCacheOptions}).Parse("Authorization: Bearer {{ $.Client.Key }}\r\n\r\n{{ $.request.ToJSON }}"))
	addrTmplCheckBalance                 = template.Must(template.New("AddressCheckBalance").Funcs(template.FuncMap{"get_cache_options": getCacheOptions}).Parse("{{ $.Client.BaseUrl }}/users/me/balance"))
	headerTmplCheckBalance               = template.Must(template.New("HeaderCheckBalance").Funcs(template.FuncMap{"get_cache_options": getCacheOptions}).Parse("Authorization: Bearer {{ $.Client.Key }}\r\n\r\n"))
	addrTmplCreateChatCompletion         = template.Must(template.New("AddressCreateChatCompletion").Funcs(template.FuncMap{"get_cache_options": getCacheOptions}).Parse("{{ $.Client.BaseUrl }}/chat/completions"))
	headerTmplCreateChatCompletion       = template.Must(template.New("HeaderCreateChatCompletion").Funcs(template.FuncMap{"get_cache_options": getCacheOptions}).Parse("Content-Type: application/json\r\nAuthorization: Bearer {{ $.Client.Key }}\r\n{{ $options := (get_cache_options $.ctx) -}}\r\n{{ if $options }}X-Msh-Context-Cache: {{ $options.CacheID }}\r\n{{ end }}{{ if $options }}{{ if $options.ResetTTL }}X-Msh-Context-Cache-Reset-TTL: {{ $options.ResetTTL }}\r\n{{ end }}{{ end }}\r\n\r\n{{ $.request.ToJSON }}"))
	addrTmplCreateChatCompletionStream   = template.Must(template.New("AddressCreateChatCompletionStream").Funcs(template.FuncMap{"get_cache_options": getCacheOptions}).Parse("{{ $.Client.BaseUrl }}/chat/completions"))
	headerTmplCreateChatCompletionStream = template.Must(template.New("HeaderCreateChatCompletionStream").Funcs(template.FuncMap{"get_cache_options": getCacheOptions}).Parse("Content-Type: application/json\r\nAuthorization: Bearer {{ $.Client.Key }}\r\n{{ $options := (get_cache_options $.ctx) -}}\r\n{{ if $options }}X-Msh-Context-Cache: {{ $options.CacheID }}\r\n{{ end }}{{ if $options }}{{ if $options.ResetTTL }}X-Msh-Context-Cache-Reset-TTL: {{ $options.ResetTTL }}\r\n{{ end }}{{ end }}\r\n\r\n{{ $.request.ToJSON }}"))
	addrTmplCreateContextCache           = template.Must(template.New("AddressCreateContextCache").Funcs(template.FuncMap{"get_cache_options": getCacheOptions}).Parse("{{ $.Client.BaseUrl }}/caching"))
	headerTmplCreateContextCache         = template.Must(template.New("HeaderCreateContextCache").Funcs(template.FuncMap{"get_cache_options": getCacheOptions}).Parse("Content-Type: application/json\r\nAuthorization: Bearer {{ $.Client.Key }}\r\n\r\n{{ $.request.ToJSON }}"))
	addrTmplRetrieveContextCache         = template.Must(template.New("AddressRetrieveContextCache").Funcs(template.FuncMap{"get_cache_options": getCacheOptions}).Parse("{{ $.Client.BaseUrl }}/caching/{{ $.cacheID }}"))
	headerTmplRetrieveContextCache       = template.Must(template.New("HeaderRetrieveContextCache").Funcs(template.FuncMap{"get_cache_options": getCacheOptions}).Parse("Content-Type: application/json\r\nAuthorization: Bearer {{ $.Client.Key }}\r\n\r\n"))
	addrTmplDeleteContextCache           = template.Must(template.New("AddressDeleteContextCache").Funcs(template.FuncMap{"get_cache_options": getCacheOptions}).Parse("{{ $.Client.BaseUrl }}/caching/{{ $.cacheID }}"))
	headerTmplDeleteContextCache         = template.Must(template.New("HeaderDeleteContextCache").Funcs(template.FuncMap{"get_cache_options": getCacheOptions}).Parse("Content-Type: application/json\r\nAuthorization: Bearer {{ $.Client.Key }}\r\n\r\n"))
	addrTmplRetrieveContextCacheTag      = template.Must(template.New("AddressRetrieveContextCacheTag").Funcs(template.FuncMap{"get_cache_options": getCacheOptions}).Parse("{{ $.Client.BaseUrl }}/caching/refs/tags/{{ $.tag }}"))
	headerTmplRetrieveContextCacheTag    = template.Must(template.New("HeaderRetrieveContextCacheTag").Funcs(template.FuncMap{"get_cache_options": getCacheOptions}).Parse("Content-Type: application/json\r\nAuthorization: Bearer {{ $.Client.Key }}\r\n\r\n"))
	addrTmplUploadFile                   = template.Must(template.New("AddressUploadFile").Funcs(template.FuncMap{"get_cache_options": getCacheOptions}).Parse("{{ $.Client.BaseUrl }}/files"))
	headerTmplUploadFile                 = template.Must(template.New("HeaderUploadFile").Funcs(template.FuncMap{"get_cache_options": getCacheOptions}).Parse("Content-Type: {{ $.request.ContentType }}\r\nAuthorization: Bearer {{ $.Client.Key }}\r\n\r\n"))
	addrTmplListFiles                    = template.Must(template.New("AddressListFiles").Funcs(template.FuncMap{"get_cache_options": getCacheOptions}).Parse("{{ $.Client.BaseUrl }}/files"))
	headerTmplListFiles                  = template.Must(template.New("HeaderListFiles").Funcs(template.FuncMap{"get_cache_options": getCacheOptions}).Parse("Authorization: Bearer {{ $.Client.Key }}\r\n\r\n"))
	addrTmplDeleteFile                   = template.Must(template.New("AddressDeleteFile").Funcs(template.FuncMap{"get_cache_options": getCacheOptions}).Parse("{{ $.Client.BaseUrl }}/files/{{ $.fileID }}"))
	headerTmplDeleteFile                 = template.Must(template.New("HeaderDeleteFile").Funcs(template.FuncMap{"get_cache_options": getCacheOptions}).Parse("Authorization: Bearer {{ $.Client.Key }}\r\n\r\n"))
	addrTmplRetrieveFileContent          = template.Must(template.New("AddressRetrieveFileContent").Funcs(template.FuncMap{"get_cache_options": getCacheOptions}).Parse("{{ $.Client.BaseUrl }}/files/{{ $.fileID }}/content"))
	headerTmplRetrieveFileContent        = template.Must(template.New("HeaderRetrieveFileContent").Funcs(template.FuncMap{"get_cache_options": getCacheOptions}).Parse("Authorization: Bearer {{ $.Client.Key }}\r\n\r\n"))
)

func (__imp *implClient[C]) ListModels(ctx context.Context) (*Models, error) {
	var innerListModels any = __imp.Inner()

	addrListModels := __ClientGetBuffer()
	defer __ClientPutBuffer(addrListModels)
	defer addrListModels.Reset()

	headerListModels := __ClientGetBuffer()
	defer __ClientPutBuffer(headerListModels)
	defer headerListModels.Reset()

	var (
		v0ListModels           = new(Models)
		errListModels          error
		httpResponseListModels *http.Response
		responseListModels     ClientResponseInterface = __imp.response()
	)

	if errListModels = addrTmplListModels.Execute(addrListModels, map[string]any{
		"Client": __imp.Inner(),
		"ctx":    ctx,
	}); errListModels != nil {
		return v0ListModels, fmt.Errorf("error building 'ListModels' url: %w", errListModels)
	}

	if errListModels = headerTmplListModels.Execute(headerListModels, map[string]any{
		"Client": __imp.Inner(),
		"ctx":    ctx,
	}); errListModels != nil {
		return v0ListModels, fmt.Errorf("error building 'ListModels' header: %w", errListModels)
	}
	bufReaderListModels := bufio.NewReader(headerListModels)
	mimeHeaderListModels, errListModels := textproto.NewReader(bufReaderListModels).ReadMIMEHeader()
	if errListModels != nil {
		return v0ListModels, fmt.Errorf("error reading 'ListModels' header: %w", errListModels)
	}

	urlListModels := addrListModels.String()
	requestListModels, errListModels := http.NewRequestWithContext(ctx, "GET", urlListModels, http.NoBody)
	if errListModels != nil {
		return v0ListModels, fmt.Errorf("error building 'ListModels' request: %w", errListModels)
	}

	for kListModels, vvListModels := range mimeHeaderListModels {
		for _, vListModels := range vvListModels {
			requestListModels.Header.Add(kListModels, vListModels)
		}
	}

	startListModels := time.Now()

	if httpClientListModels, okListModels := innerListModels.(interface{ Client() *http.Client }); okListModels {
		httpResponseListModels, errListModels = httpClientListModels.Client().Do(requestListModels)
	} else {
		httpResponseListModels, errListModels = http.DefaultClient.Do(requestListModels)
	}

	if logListModels, okListModels := innerListModels.(interface {
		Log(ctx context.Context, caller string, request *http.Request, response *http.Response, elapse time.Duration)
	}); okListModels {
		logListModels.Log(ctx, "ListModels", requestListModels, httpResponseListModels, time.Since(startListModels))
	}

	if errListModels != nil {
		return v0ListModels, fmt.Errorf("error sending 'ListModels' request: %w", errListModels)
	}

	if httpResponseListModels.StatusCode < 200 || httpResponseListModels.StatusCode > 299 {
		return v0ListModels, __ClientNewResponseError("ListModels", httpResponseListModels)
	}

	if errListModels = responseListModels.FromResponse("ListModels", httpResponseListModels); errListModels != nil {
		return v0ListModels, fmt.Errorf("error converting 'ListModels' response: %w", errListModels)
	}

	addrListModels.Reset()
	headerListModels.Reset()

	if errListModels = responseListModels.Err(); errListModels != nil {
		return v0ListModels, fmt.Errorf("error returned from 'ListModels' response: %w", errListModels)
	}

	if errListModels = responseListModels.ScanValues(v0ListModels); errListModels != nil {
		return v0ListModels, fmt.Errorf("error scanning value from 'ListModels' response: %w", errListModels)
	}

	return v0ListModels, nil
}

func (__imp *implClient[C]) EstimateTokenCount(ctx context.Context, request *EstimateTokenCountRequest) (*EstimateTokenCount, error) {
	var innerEstimateTokenCount any = __imp.Inner()

	addrEstimateTokenCount := __ClientGetBuffer()
	defer __ClientPutBuffer(addrEstimateTokenCount)
	defer addrEstimateTokenCount.Reset()

	headerEstimateTokenCount := __ClientGetBuffer()
	defer __ClientPutBuffer(headerEstimateTokenCount)
	defer headerEstimateTokenCount.Reset()

	var (
		v0EstimateTokenCount           = new(EstimateTokenCount)
		errEstimateTokenCount          error
		httpResponseEstimateTokenCount *http.Response
		responseEstimateTokenCount     ClientResponseInterface = __imp.response()
	)

	if errEstimateTokenCount = addrTmplEstimateTokenCount.Execute(addrEstimateTokenCount, map[string]any{
		"Client":  __imp.Inner(),
		"ctx":     ctx,
		"request": request,
	}); errEstimateTokenCount != nil {
		return v0EstimateTokenCount, fmt.Errorf("error building 'EstimateTokenCount' url: %w", errEstimateTokenCount)
	}

	if errEstimateTokenCount = headerTmplEstimateTokenCount.Execute(headerEstimateTokenCount, map[string]any{
		"Client":  __imp.Inner(),
		"ctx":     ctx,
		"request": request,
	}); errEstimateTokenCount != nil {
		return v0EstimateTokenCount, fmt.Errorf("error building 'EstimateTokenCount' header: %w", errEstimateTokenCount)
	}
	bufReaderEstimateTokenCount := bufio.NewReader(headerEstimateTokenCount)
	mimeHeaderEstimateTokenCount, errEstimateTokenCount := textproto.NewReader(bufReaderEstimateTokenCount).ReadMIMEHeader()
	if errEstimateTokenCount != nil {
		return v0EstimateTokenCount, fmt.Errorf("error reading 'EstimateTokenCount' header: %w", errEstimateTokenCount)
	}

	urlEstimateTokenCount := addrEstimateTokenCount.String()
	requestBodyEstimateTokenCount, errEstimateTokenCount := io.ReadAll(bufReaderEstimateTokenCount)
	if errEstimateTokenCount != nil {
		return v0EstimateTokenCount, fmt.Errorf("error reading 'EstimateTokenCount' request body: %w", errEstimateTokenCount)
	}
	requestEstimateTokenCount, errEstimateTokenCount := http.NewRequestWithContext(ctx, "POST", urlEstimateTokenCount, bytes.NewReader(requestBodyEstimateTokenCount))
	if errEstimateTokenCount != nil {
		return v0EstimateTokenCount, fmt.Errorf("error building 'EstimateTokenCount' request: %w", errEstimateTokenCount)
	}

	for kEstimateTokenCount, vvEstimateTokenCount := range mimeHeaderEstimateTokenCount {
		for _, vEstimateTokenCount := range vvEstimateTokenCount {
			requestEstimateTokenCount.Header.Add(kEstimateTokenCount, vEstimateTokenCount)
		}
	}

	startEstimateTokenCount := time.Now()

	if httpClientEstimateTokenCount, okEstimateTokenCount := innerEstimateTokenCount.(interface{ Client() *http.Client }); okEstimateTokenCount {
		httpResponseEstimateTokenCount, errEstimateTokenCount = httpClientEstimateTokenCount.Client().Do(requestEstimateTokenCount)
	} else {
		httpResponseEstimateTokenCount, errEstimateTokenCount = http.DefaultClient.Do(requestEstimateTokenCount)
	}

	if logEstimateTokenCount, okEstimateTokenCount := innerEstimateTokenCount.(interface {
		Log(ctx context.Context, caller string, request *http.Request, response *http.Response, elapse time.Duration)
	}); okEstimateTokenCount {
		logEstimateTokenCount.Log(ctx, "EstimateTokenCount", requestEstimateTokenCount, httpResponseEstimateTokenCount, time.Since(startEstimateTokenCount))
	}

	if errEstimateTokenCount != nil {
		return v0EstimateTokenCount, fmt.Errorf("error sending 'EstimateTokenCount' request: %w", errEstimateTokenCount)
	}

	if httpResponseEstimateTokenCount.StatusCode < 200 || httpResponseEstimateTokenCount.StatusCode > 299 {
		return v0EstimateTokenCount, __ClientNewResponseError("EstimateTokenCount", httpResponseEstimateTokenCount)
	}

	if errEstimateTokenCount = responseEstimateTokenCount.FromResponse("EstimateTokenCount", httpResponseEstimateTokenCount); errEstimateTokenCount != nil {
		return v0EstimateTokenCount, fmt.Errorf("error converting 'EstimateTokenCount' response: %w", errEstimateTokenCount)
	}

	addrEstimateTokenCount.Reset()
	headerEstimateTokenCount.Reset()

	if errEstimateTokenCount = responseEstimateTokenCount.Err(); errEstimateTokenCount != nil {
		return v0EstimateTokenCount, fmt.Errorf("error returned from 'EstimateTokenCount' response: %w", errEstimateTokenCount)
	}

	if errEstimateTokenCount = responseEstimateTokenCount.ScanValues(v0EstimateTokenCount); errEstimateTokenCount != nil {
		return v0EstimateTokenCount, fmt.Errorf("error scanning value from 'EstimateTokenCount' response: %w", errEstimateTokenCount)
	}

	return v0EstimateTokenCount, nil
}

func (__imp *implClient[C]) CheckBalance(ctx context.Context) (*Balance, error) {
	var innerCheckBalance any = __imp.Inner()

	addrCheckBalance := __ClientGetBuffer()
	defer __ClientPutBuffer(addrCheckBalance)
	defer addrCheckBalance.Reset()

	headerCheckBalance := __ClientGetBuffer()
	defer __ClientPutBuffer(headerCheckBalance)
	defer headerCheckBalance.Reset()

	var (
		v0CheckBalance           = new(Balance)
		errCheckBalance          error
		httpResponseCheckBalance *http.Response
		responseCheckBalance     ClientResponseInterface = __imp.response()
	)

	if errCheckBalance = addrTmplCheckBalance.Execute(addrCheckBalance, map[string]any{
		"Client": __imp.Inner(),
		"ctx":    ctx,
	}); errCheckBalance != nil {
		return v0CheckBalance, fmt.Errorf("error building 'CheckBalance' url: %w", errCheckBalance)
	}

	if errCheckBalance = headerTmplCheckBalance.Execute(headerCheckBalance, map[string]any{
		"Client": __imp.Inner(),
		"ctx":    ctx,
	}); errCheckBalance != nil {
		return v0CheckBalance, fmt.Errorf("error building 'CheckBalance' header: %w", errCheckBalance)
	}
	bufReaderCheckBalance := bufio.NewReader(headerCheckBalance)
	mimeHeaderCheckBalance, errCheckBalance := textproto.NewReader(bufReaderCheckBalance).ReadMIMEHeader()
	if errCheckBalance != nil {
		return v0CheckBalance, fmt.Errorf("error reading 'CheckBalance' header: %w", errCheckBalance)
	}

	urlCheckBalance := addrCheckBalance.String()
	requestCheckBalance, errCheckBalance := http.NewRequestWithContext(ctx, "GET", urlCheckBalance, http.NoBody)
	if errCheckBalance != nil {
		return v0CheckBalance, fmt.Errorf("error building 'CheckBalance' request: %w", errCheckBalance)
	}

	for kCheckBalance, vvCheckBalance := range mimeHeaderCheckBalance {
		for _, vCheckBalance := range vvCheckBalance {
			requestCheckBalance.Header.Add(kCheckBalance, vCheckBalance)
		}
	}

	startCheckBalance := time.Now()

	if httpClientCheckBalance, okCheckBalance := innerCheckBalance.(interface{ Client() *http.Client }); okCheckBalance {
		httpResponseCheckBalance, errCheckBalance = httpClientCheckBalance.Client().Do(requestCheckBalance)
	} else {
		httpResponseCheckBalance, errCheckBalance = http.DefaultClient.Do(requestCheckBalance)
	}

	if logCheckBalance, okCheckBalance := innerCheckBalance.(interface {
		Log(ctx context.Context, caller string, request *http.Request, response *http.Response, elapse time.Duration)
	}); okCheckBalance {
		logCheckBalance.Log(ctx, "CheckBalance", requestCheckBalance, httpResponseCheckBalance, time.Since(startCheckBalance))
	}

	if errCheckBalance != nil {
		return v0CheckBalance, fmt.Errorf("error sending 'CheckBalance' request: %w", errCheckBalance)
	}

	if httpResponseCheckBalance.StatusCode < 200 || httpResponseCheckBalance.StatusCode > 299 {
		return v0CheckBalance, __ClientNewResponseError("CheckBalance", httpResponseCheckBalance)
	}

	if errCheckBalance = responseCheckBalance.FromResponse("CheckBalance", httpResponseCheckBalance); errCheckBalance != nil {
		return v0CheckBalance, fmt.Errorf("error converting 'CheckBalance' response: %w", errCheckBalance)
	}

	addrCheckBalance.Reset()
	headerCheckBalance.Reset()

	if errCheckBalance = responseCheckBalance.Err(); errCheckBalance != nil {
		return v0CheckBalance, fmt.Errorf("error returned from 'CheckBalance' response: %w", errCheckBalance)
	}

	if errCheckBalance = responseCheckBalance.ScanValues(v0CheckBalance); errCheckBalance != nil {
		return v0CheckBalance, fmt.Errorf("error scanning value from 'CheckBalance' response: %w", errCheckBalance)
	}

	return v0CheckBalance, nil
}

func (__imp *implClient[C]) CreateChatCompletion(ctx context.Context, request *ChatCompletionRequest) (*Completion, error) {
	var innerCreateChatCompletion any = __imp.Inner()

	addrCreateChatCompletion := __ClientGetBuffer()
	defer __ClientPutBuffer(addrCreateChatCompletion)
	defer addrCreateChatCompletion.Reset()

	headerCreateChatCompletion := __ClientGetBuffer()
	defer __ClientPutBuffer(headerCreateChatCompletion)
	defer headerCreateChatCompletion.Reset()

	var (
		v0CreateChatCompletion           = new(Completion)
		errCreateChatCompletion          error
		httpResponseCreateChatCompletion *http.Response
		responseCreateChatCompletion     ClientResponseInterface = __imp.response()
	)

	if errCreateChatCompletion = addrTmplCreateChatCompletion.Execute(addrCreateChatCompletion, map[string]any{
		"Client":  __imp.Inner(),
		"ctx":     ctx,
		"request": request,
	}); errCreateChatCompletion != nil {
		return v0CreateChatCompletion, fmt.Errorf("error building 'CreateChatCompletion' url: %w", errCreateChatCompletion)
	}

	if errCreateChatCompletion = headerTmplCreateChatCompletion.Execute(headerCreateChatCompletion, map[string]any{
		"Client":  __imp.Inner(),
		"ctx":     ctx,
		"request": request,
	}); errCreateChatCompletion != nil {
		return v0CreateChatCompletion, fmt.Errorf("error building 'CreateChatCompletion' header: %w", errCreateChatCompletion)
	}
	bufReaderCreateChatCompletion := bufio.NewReader(headerCreateChatCompletion)
	mimeHeaderCreateChatCompletion, errCreateChatCompletion := textproto.NewReader(bufReaderCreateChatCompletion).ReadMIMEHeader()
	if errCreateChatCompletion != nil {
		return v0CreateChatCompletion, fmt.Errorf("error reading 'CreateChatCompletion' header: %w", errCreateChatCompletion)
	}

	urlCreateChatCompletion := addrCreateChatCompletion.String()
	requestBodyCreateChatCompletion, errCreateChatCompletion := io.ReadAll(bufReaderCreateChatCompletion)
	if errCreateChatCompletion != nil {
		return v0CreateChatCompletion, fmt.Errorf("error reading 'CreateChatCompletion' request body: %w", errCreateChatCompletion)
	}
	requestCreateChatCompletion, errCreateChatCompletion := http.NewRequestWithContext(ctx, "POST", urlCreateChatCompletion, bytes.NewReader(requestBodyCreateChatCompletion))
	if errCreateChatCompletion != nil {
		return v0CreateChatCompletion, fmt.Errorf("error building 'CreateChatCompletion' request: %w", errCreateChatCompletion)
	}

	for kCreateChatCompletion, vvCreateChatCompletion := range mimeHeaderCreateChatCompletion {
		for _, vCreateChatCompletion := range vvCreateChatCompletion {
			requestCreateChatCompletion.Header.Add(kCreateChatCompletion, vCreateChatCompletion)
		}
	}

	startCreateChatCompletion := time.Now()

	if httpClientCreateChatCompletion, okCreateChatCompletion := innerCreateChatCompletion.(interface{ Client() *http.Client }); okCreateChatCompletion {
		httpResponseCreateChatCompletion, errCreateChatCompletion = httpClientCreateChatCompletion.Client().Do(requestCreateChatCompletion)
	} else {
		httpResponseCreateChatCompletion, errCreateChatCompletion = http.DefaultClient.Do(requestCreateChatCompletion)
	}

	if logCreateChatCompletion, okCreateChatCompletion := innerCreateChatCompletion.(interface {
		Log(ctx context.Context, caller string, request *http.Request, response *http.Response, elapse time.Duration)
	}); okCreateChatCompletion {
		logCreateChatCompletion.Log(ctx, "CreateChatCompletion", requestCreateChatCompletion, httpResponseCreateChatCompletion, time.Since(startCreateChatCompletion))
	}

	if errCreateChatCompletion != nil {
		return v0CreateChatCompletion, fmt.Errorf("error sending 'CreateChatCompletion' request: %w", errCreateChatCompletion)
	}

	if httpResponseCreateChatCompletion.StatusCode < 200 || httpResponseCreateChatCompletion.StatusCode > 299 {
		return v0CreateChatCompletion, __ClientNewResponseError("CreateChatCompletion", httpResponseCreateChatCompletion)
	}

	if errCreateChatCompletion = responseCreateChatCompletion.FromResponse("CreateChatCompletion", httpResponseCreateChatCompletion); errCreateChatCompletion != nil {
		return v0CreateChatCompletion, fmt.Errorf("error converting 'CreateChatCompletion' response: %w", errCreateChatCompletion)
	}

	addrCreateChatCompletion.Reset()
	headerCreateChatCompletion.Reset()

	if errCreateChatCompletion = responseCreateChatCompletion.Err(); errCreateChatCompletion != nil {
		return v0CreateChatCompletion, fmt.Errorf("error returned from 'CreateChatCompletion' response: %w", errCreateChatCompletion)
	}

	if errCreateChatCompletion = responseCreateChatCompletion.ScanValues(v0CreateChatCompletion); errCreateChatCompletion != nil {
		return v0CreateChatCompletion, fmt.Errorf("error scanning value from 'CreateChatCompletion' response: %w", errCreateChatCompletion)
	}

	return v0CreateChatCompletion, nil
}

func (__imp *implClient[C]) CreateChatCompletionStream(ctx context.Context, request *ChatCompletionStreamRequest) (*Stream, error) {
	var innerCreateChatCompletionStream any = __imp.Inner()

	addrCreateChatCompletionStream := __ClientGetBuffer()
	defer __ClientPutBuffer(addrCreateChatCompletionStream)
	defer addrCreateChatCompletionStream.Reset()

	headerCreateChatCompletionStream := __ClientGetBuffer()
	defer __ClientPutBuffer(headerCreateChatCompletionStream)
	defer headerCreateChatCompletionStream.Reset()

	var (
		v0CreateChatCompletionStream           = new(Stream)
		errCreateChatCompletionStream          error
		httpResponseCreateChatCompletionStream *http.Response
		responseCreateChatCompletionStream     ClientResponseInterface = __imp.response()
	)

	if errCreateChatCompletionStream = addrTmplCreateChatCompletionStream.Execute(addrCreateChatCompletionStream, map[string]any{
		"Client":  __imp.Inner(),
		"ctx":     ctx,
		"request": request,
	}); errCreateChatCompletionStream != nil {
		return v0CreateChatCompletionStream, fmt.Errorf("error building 'CreateChatCompletionStream' url: %w", errCreateChatCompletionStream)
	}

	if errCreateChatCompletionStream = headerTmplCreateChatCompletionStream.Execute(headerCreateChatCompletionStream, map[string]any{
		"Client":  __imp.Inner(),
		"ctx":     ctx,
		"request": request,
	}); errCreateChatCompletionStream != nil {
		return v0CreateChatCompletionStream, fmt.Errorf("error building 'CreateChatCompletionStream' header: %w", errCreateChatCompletionStream)
	}
	bufReaderCreateChatCompletionStream := bufio.NewReader(headerCreateChatCompletionStream)
	mimeHeaderCreateChatCompletionStream, errCreateChatCompletionStream := textproto.NewReader(bufReaderCreateChatCompletionStream).ReadMIMEHeader()
	if errCreateChatCompletionStream != nil {
		return v0CreateChatCompletionStream, fmt.Errorf("error reading 'CreateChatCompletionStream' header: %w", errCreateChatCompletionStream)
	}

	urlCreateChatCompletionStream := addrCreateChatCompletionStream.String()
	requestBodyCreateChatCompletionStream, errCreateChatCompletionStream := io.ReadAll(bufReaderCreateChatCompletionStream)
	if errCreateChatCompletionStream != nil {
		return v0CreateChatCompletionStream, fmt.Errorf("error reading 'CreateChatCompletionStream' request body: %w", errCreateChatCompletionStream)
	}
	requestCreateChatCompletionStream, errCreateChatCompletionStream := http.NewRequestWithContext(ctx, "POST", urlCreateChatCompletionStream, bytes.NewReader(requestBodyCreateChatCompletionStream))
	if errCreateChatCompletionStream != nil {
		return v0CreateChatCompletionStream, fmt.Errorf("error building 'CreateChatCompletionStream' request: %w", errCreateChatCompletionStream)
	}

	for kCreateChatCompletionStream, vvCreateChatCompletionStream := range mimeHeaderCreateChatCompletionStream {
		for _, vCreateChatCompletionStream := range vvCreateChatCompletionStream {
			requestCreateChatCompletionStream.Header.Add(kCreateChatCompletionStream, vCreateChatCompletionStream)
		}
	}

	startCreateChatCompletionStream := time.Now()

	if httpClientCreateChatCompletionStream, okCreateChatCompletionStream := innerCreateChatCompletionStream.(interface{ Client() *http.Client }); okCreateChatCompletionStream {
		httpResponseCreateChatCompletionStream, errCreateChatCompletionStream = httpClientCreateChatCompletionStream.Client().Do(requestCreateChatCompletionStream)
	} else {
		httpResponseCreateChatCompletionStream, errCreateChatCompletionStream = http.DefaultClient.Do(requestCreateChatCompletionStream)
	}

	if logCreateChatCompletionStream, okCreateChatCompletionStream := innerCreateChatCompletionStream.(interface {
		Log(ctx context.Context, caller string, request *http.Request, response *http.Response, elapse time.Duration)
	}); okCreateChatCompletionStream {
		logCreateChatCompletionStream.Log(ctx, "CreateChatCompletionStream", requestCreateChatCompletionStream, httpResponseCreateChatCompletionStream, time.Since(startCreateChatCompletionStream))
	}

	if errCreateChatCompletionStream != nil {
		return v0CreateChatCompletionStream, fmt.Errorf("error sending 'CreateChatCompletionStream' request: %w", errCreateChatCompletionStream)
	}

	if httpResponseCreateChatCompletionStream.StatusCode < 200 || httpResponseCreateChatCompletionStream.StatusCode > 299 {
		return v0CreateChatCompletionStream, __ClientNewResponseError("CreateChatCompletionStream", httpResponseCreateChatCompletionStream)
	}

	if errCreateChatCompletionStream = responseCreateChatCompletionStream.FromResponse("CreateChatCompletionStream", httpResponseCreateChatCompletionStream); errCreateChatCompletionStream != nil {
		return v0CreateChatCompletionStream, fmt.Errorf("error converting 'CreateChatCompletionStream' response: %w", errCreateChatCompletionStream)
	}

	addrCreateChatCompletionStream.Reset()
	headerCreateChatCompletionStream.Reset()

	if errCreateChatCompletionStream = responseCreateChatCompletionStream.Err(); errCreateChatCompletionStream != nil {
		return v0CreateChatCompletionStream, fmt.Errorf("error returned from 'CreateChatCompletionStream' response: %w", errCreateChatCompletionStream)
	}

	if errCreateChatCompletionStream = responseCreateChatCompletionStream.ScanValues(v0CreateChatCompletionStream); errCreateChatCompletionStream != nil {
		return v0CreateChatCompletionStream, fmt.Errorf("error scanning value from 'CreateChatCompletionStream' response: %w", errCreateChatCompletionStream)
	}

	return v0CreateChatCompletionStream, nil
}

func (__imp *implClient[C]) CreateContextCache(ctx context.Context, request *CreateContextCacheRequest) (*ContextCache, error) {
	var innerCreateContextCache any = __imp.Inner()

	addrCreateContextCache := __ClientGetBuffer()
	defer __ClientPutBuffer(addrCreateContextCache)
	defer addrCreateContextCache.Reset()

	headerCreateContextCache := __ClientGetBuffer()
	defer __ClientPutBuffer(headerCreateContextCache)
	defer headerCreateContextCache.Reset()

	var (
		v0CreateContextCache           = new(ContextCache)
		errCreateContextCache          error
		httpResponseCreateContextCache *http.Response
		responseCreateContextCache     ClientResponseInterface = __imp.response()
	)

	if errCreateContextCache = addrTmplCreateContextCache.Execute(addrCreateContextCache, map[string]any{
		"Client":  __imp.Inner(),
		"ctx":     ctx,
		"request": request,
	}); errCreateContextCache != nil {
		return v0CreateContextCache, fmt.Errorf("error building 'CreateContextCache' url: %w", errCreateContextCache)
	}

	if errCreateContextCache = headerTmplCreateContextCache.Execute(headerCreateContextCache, map[string]any{
		"Client":  __imp.Inner(),
		"ctx":     ctx,
		"request": request,
	}); errCreateContextCache != nil {
		return v0CreateContextCache, fmt.Errorf("error building 'CreateContextCache' header: %w", errCreateContextCache)
	}
	bufReaderCreateContextCache := bufio.NewReader(headerCreateContextCache)
	mimeHeaderCreateContextCache, errCreateContextCache := textproto.NewReader(bufReaderCreateContextCache).ReadMIMEHeader()
	if errCreateContextCache != nil {
		return v0CreateContextCache, fmt.Errorf("error reading 'CreateContextCache' header: %w", errCreateContextCache)
	}

	urlCreateContextCache := addrCreateContextCache.String()
	requestBodyCreateContextCache, errCreateContextCache := io.ReadAll(bufReaderCreateContextCache)
	if errCreateContextCache != nil {
		return v0CreateContextCache, fmt.Errorf("error reading 'CreateContextCache' request body: %w", errCreateContextCache)
	}
	requestCreateContextCache, errCreateContextCache := http.NewRequestWithContext(ctx, "POST", urlCreateContextCache, bytes.NewReader(requestBodyCreateContextCache))
	if errCreateContextCache != nil {
		return v0CreateContextCache, fmt.Errorf("error building 'CreateContextCache' request: %w", errCreateContextCache)
	}

	for kCreateContextCache, vvCreateContextCache := range mimeHeaderCreateContextCache {
		for _, vCreateContextCache := range vvCreateContextCache {
			requestCreateContextCache.Header.Add(kCreateContextCache, vCreateContextCache)
		}
	}

	startCreateContextCache := time.Now()

	if httpClientCreateContextCache, okCreateContextCache := innerCreateContextCache.(interface{ Client() *http.Client }); okCreateContextCache {
		httpResponseCreateContextCache, errCreateContextCache = httpClientCreateContextCache.Client().Do(requestCreateContextCache)
	} else {
		httpResponseCreateContextCache, errCreateContextCache = http.DefaultClient.Do(requestCreateContextCache)
	}

	if logCreateContextCache, okCreateContextCache := innerCreateContextCache.(interface {
		Log(ctx context.Context, caller string, request *http.Request, response *http.Response, elapse time.Duration)
	}); okCreateContextCache {
		logCreateContextCache.Log(ctx, "CreateContextCache", requestCreateContextCache, httpResponseCreateContextCache, time.Since(startCreateContextCache))
	}

	if errCreateContextCache != nil {
		return v0CreateContextCache, fmt.Errorf("error sending 'CreateContextCache' request: %w", errCreateContextCache)
	}

	if httpResponseCreateContextCache.StatusCode < 200 || httpResponseCreateContextCache.StatusCode > 299 {
		return v0CreateContextCache, __ClientNewResponseError("CreateContextCache", httpResponseCreateContextCache)
	}

	if errCreateContextCache = responseCreateContextCache.FromResponse("CreateContextCache", httpResponseCreateContextCache); errCreateContextCache != nil {
		return v0CreateContextCache, fmt.Errorf("error converting 'CreateContextCache' response: %w", errCreateContextCache)
	}

	addrCreateContextCache.Reset()
	headerCreateContextCache.Reset()

	if errCreateContextCache = responseCreateContextCache.Err(); errCreateContextCache != nil {
		return v0CreateContextCache, fmt.Errorf("error returned from 'CreateContextCache' response: %w", errCreateContextCache)
	}

	if errCreateContextCache = responseCreateContextCache.ScanValues(v0CreateContextCache); errCreateContextCache != nil {
		return v0CreateContextCache, fmt.Errorf("error scanning value from 'CreateContextCache' response: %w", errCreateContextCache)
	}

	return v0CreateContextCache, nil
}

func (__imp *implClient[C]) RetrieveContextCache(ctx context.Context, cacheID string) (*ContextCache, error) {
	var innerRetrieveContextCache any = __imp.Inner()

	addrRetrieveContextCache := __ClientGetBuffer()
	defer __ClientPutBuffer(addrRetrieveContextCache)
	defer addrRetrieveContextCache.Reset()

	headerRetrieveContextCache := __ClientGetBuffer()
	defer __ClientPutBuffer(headerRetrieveContextCache)
	defer headerRetrieveContextCache.Reset()

	var (
		v0RetrieveContextCache           = new(ContextCache)
		errRetrieveContextCache          error
		httpResponseRetrieveContextCache *http.Response
		responseRetrieveContextCache     ClientResponseInterface = __imp.response()
	)

	if errRetrieveContextCache = addrTmplRetrieveContextCache.Execute(addrRetrieveContextCache, map[string]any{
		"Client":  __imp.Inner(),
		"ctx":     ctx,
		"cacheID": cacheID,
	}); errRetrieveContextCache != nil {
		return v0RetrieveContextCache, fmt.Errorf("error building 'RetrieveContextCache' url: %w", errRetrieveContextCache)
	}

	if errRetrieveContextCache = headerTmplRetrieveContextCache.Execute(headerRetrieveContextCache, map[string]any{
		"Client":  __imp.Inner(),
		"ctx":     ctx,
		"cacheID": cacheID,
	}); errRetrieveContextCache != nil {
		return v0RetrieveContextCache, fmt.Errorf("error building 'RetrieveContextCache' header: %w", errRetrieveContextCache)
	}
	bufReaderRetrieveContextCache := bufio.NewReader(headerRetrieveContextCache)
	mimeHeaderRetrieveContextCache, errRetrieveContextCache := textproto.NewReader(bufReaderRetrieveContextCache).ReadMIMEHeader()
	if errRetrieveContextCache != nil {
		return v0RetrieveContextCache, fmt.Errorf("error reading 'RetrieveContextCache' header: %w", errRetrieveContextCache)
	}

	urlRetrieveContextCache := addrRetrieveContextCache.String()
	requestRetrieveContextCache, errRetrieveContextCache := http.NewRequestWithContext(ctx, "GET", urlRetrieveContextCache, http.NoBody)
	if errRetrieveContextCache != nil {
		return v0RetrieveContextCache, fmt.Errorf("error building 'RetrieveContextCache' request: %w", errRetrieveContextCache)
	}

	for kRetrieveContextCache, vvRetrieveContextCache := range mimeHeaderRetrieveContextCache {
		for _, vRetrieveContextCache := range vvRetrieveContextCache {
			requestRetrieveContextCache.Header.Add(kRetrieveContextCache, vRetrieveContextCache)
		}
	}

	startRetrieveContextCache := time.Now()

	if httpClientRetrieveContextCache, okRetrieveContextCache := innerRetrieveContextCache.(interface{ Client() *http.Client }); okRetrieveContextCache {
		httpResponseRetrieveContextCache, errRetrieveContextCache = httpClientRetrieveContextCache.Client().Do(requestRetrieveContextCache)
	} else {
		httpResponseRetrieveContextCache, errRetrieveContextCache = http.DefaultClient.Do(requestRetrieveContextCache)
	}

	if logRetrieveContextCache, okRetrieveContextCache := innerRetrieveContextCache.(interface {
		Log(ctx context.Context, caller string, request *http.Request, response *http.Response, elapse time.Duration)
	}); okRetrieveContextCache {
		logRetrieveContextCache.Log(ctx, "RetrieveContextCache", requestRetrieveContextCache, httpResponseRetrieveContextCache, time.Since(startRetrieveContextCache))
	}

	if errRetrieveContextCache != nil {
		return v0RetrieveContextCache, fmt.Errorf("error sending 'RetrieveContextCache' request: %w", errRetrieveContextCache)
	}

	if httpResponseRetrieveContextCache.StatusCode < 200 || httpResponseRetrieveContextCache.StatusCode > 299 {
		return v0RetrieveContextCache, __ClientNewResponseError("RetrieveContextCache", httpResponseRetrieveContextCache)
	}

	if errRetrieveContextCache = responseRetrieveContextCache.FromResponse("RetrieveContextCache", httpResponseRetrieveContextCache); errRetrieveContextCache != nil {
		return v0RetrieveContextCache, fmt.Errorf("error converting 'RetrieveContextCache' response: %w", errRetrieveContextCache)
	}

	addrRetrieveContextCache.Reset()
	headerRetrieveContextCache.Reset()

	if errRetrieveContextCache = responseRetrieveContextCache.Err(); errRetrieveContextCache != nil {
		return v0RetrieveContextCache, fmt.Errorf("error returned from 'RetrieveContextCache' response: %w", errRetrieveContextCache)
	}

	if errRetrieveContextCache = responseRetrieveContextCache.ScanValues(v0RetrieveContextCache); errRetrieveContextCache != nil {
		return v0RetrieveContextCache, fmt.Errorf("error scanning value from 'RetrieveContextCache' response: %w", errRetrieveContextCache)
	}

	return v0RetrieveContextCache, nil
}

func (__imp *implClient[C]) DeleteContextCache(ctx context.Context, cacheID string) error {
	var innerDeleteContextCache any = __imp.Inner()

	addrDeleteContextCache := __ClientGetBuffer()
	defer __ClientPutBuffer(addrDeleteContextCache)
	defer addrDeleteContextCache.Reset()

	headerDeleteContextCache := __ClientGetBuffer()
	defer __ClientPutBuffer(headerDeleteContextCache)
	defer headerDeleteContextCache.Reset()

	var (
		errDeleteContextCache          error
		httpResponseDeleteContextCache *http.Response
		responseDeleteContextCache     ClientResponseInterface = __imp.response()
	)

	if errDeleteContextCache = addrTmplDeleteContextCache.Execute(addrDeleteContextCache, map[string]any{
		"Client":  __imp.Inner(),
		"ctx":     ctx,
		"cacheID": cacheID,
	}); errDeleteContextCache != nil {
		return fmt.Errorf("error building 'DeleteContextCache' url: %w", errDeleteContextCache)
	}

	if errDeleteContextCache = headerTmplDeleteContextCache.Execute(headerDeleteContextCache, map[string]any{
		"Client":  __imp.Inner(),
		"ctx":     ctx,
		"cacheID": cacheID,
	}); errDeleteContextCache != nil {
		return fmt.Errorf("error building 'DeleteContextCache' header: %w", errDeleteContextCache)
	}
	bufReaderDeleteContextCache := bufio.NewReader(headerDeleteContextCache)
	mimeHeaderDeleteContextCache, errDeleteContextCache := textproto.NewReader(bufReaderDeleteContextCache).ReadMIMEHeader()
	if errDeleteContextCache != nil {
		return fmt.Errorf("error reading 'DeleteContextCache' header: %w", errDeleteContextCache)
	}

	urlDeleteContextCache := addrDeleteContextCache.String()
	requestDeleteContextCache, errDeleteContextCache := http.NewRequestWithContext(ctx, "DELETE", urlDeleteContextCache, http.NoBody)
	if errDeleteContextCache != nil {
		return fmt.Errorf("error building 'DeleteContextCache' request: %w", errDeleteContextCache)
	}

	for kDeleteContextCache, vvDeleteContextCache := range mimeHeaderDeleteContextCache {
		for _, vDeleteContextCache := range vvDeleteContextCache {
			requestDeleteContextCache.Header.Add(kDeleteContextCache, vDeleteContextCache)
		}
	}

	startDeleteContextCache := time.Now()

	if httpClientDeleteContextCache, okDeleteContextCache := innerDeleteContextCache.(interface{ Client() *http.Client }); okDeleteContextCache {
		httpResponseDeleteContextCache, errDeleteContextCache = httpClientDeleteContextCache.Client().Do(requestDeleteContextCache)
	} else {
		httpResponseDeleteContextCache, errDeleteContextCache = http.DefaultClient.Do(requestDeleteContextCache)
	}

	if logDeleteContextCache, okDeleteContextCache := innerDeleteContextCache.(interface {
		Log(ctx context.Context, caller string, request *http.Request, response *http.Response, elapse time.Duration)
	}); okDeleteContextCache {
		logDeleteContextCache.Log(ctx, "DeleteContextCache", requestDeleteContextCache, httpResponseDeleteContextCache, time.Since(startDeleteContextCache))
	}

	if errDeleteContextCache != nil {
		return fmt.Errorf("error sending 'DeleteContextCache' request: %w", errDeleteContextCache)
	}

	if httpResponseDeleteContextCache.StatusCode < 200 || httpResponseDeleteContextCache.StatusCode > 299 {
		return __ClientNewResponseError("DeleteContextCache", httpResponseDeleteContextCache)
	}

	if errDeleteContextCache = responseDeleteContextCache.FromResponse("DeleteContextCache", httpResponseDeleteContextCache); errDeleteContextCache != nil {
		return fmt.Errorf("error converting 'DeleteContextCache' response: %w", errDeleteContextCache)
	}

	addrDeleteContextCache.Reset()
	headerDeleteContextCache.Reset()

	if errDeleteContextCache = responseDeleteContextCache.Err(); errDeleteContextCache != nil {
		return fmt.Errorf("error returned from 'DeleteContextCache' response: %w", errDeleteContextCache)
	}

	if errDeleteContextCache = responseDeleteContextCache.ScanValues(); errDeleteContextCache != nil {
		return fmt.Errorf("error scanning value from 'DeleteContextCache' response: %w", errDeleteContextCache)
	}

	return nil
}

func (__imp *implClient[C]) RetrieveContextCacheTag(ctx context.Context, tag string) (*ContextCacheTag, error) {
	var innerRetrieveContextCacheTag any = __imp.Inner()

	addrRetrieveContextCacheTag := __ClientGetBuffer()
	defer __ClientPutBuffer(addrRetrieveContextCacheTag)
	defer addrRetrieveContextCacheTag.Reset()

	headerRetrieveContextCacheTag := __ClientGetBuffer()
	defer __ClientPutBuffer(headerRetrieveContextCacheTag)
	defer headerRetrieveContextCacheTag.Reset()

	var (
		v0RetrieveContextCacheTag           = new(ContextCacheTag)
		errRetrieveContextCacheTag          error
		httpResponseRetrieveContextCacheTag *http.Response
		responseRetrieveContextCacheTag     ClientResponseInterface = __imp.response()
	)

	if errRetrieveContextCacheTag = addrTmplRetrieveContextCacheTag.Execute(addrRetrieveContextCacheTag, map[string]any{
		"Client": __imp.Inner(),
		"ctx":    ctx,
		"tag":    tag,
	}); errRetrieveContextCacheTag != nil {
		return v0RetrieveContextCacheTag, fmt.Errorf("error building 'RetrieveContextCacheTag' url: %w", errRetrieveContextCacheTag)
	}

	if errRetrieveContextCacheTag = headerTmplRetrieveContextCacheTag.Execute(headerRetrieveContextCacheTag, map[string]any{
		"Client": __imp.Inner(),
		"ctx":    ctx,
		"tag":    tag,
	}); errRetrieveContextCacheTag != nil {
		return v0RetrieveContextCacheTag, fmt.Errorf("error building 'RetrieveContextCacheTag' header: %w", errRetrieveContextCacheTag)
	}
	bufReaderRetrieveContextCacheTag := bufio.NewReader(headerRetrieveContextCacheTag)
	mimeHeaderRetrieveContextCacheTag, errRetrieveContextCacheTag := textproto.NewReader(bufReaderRetrieveContextCacheTag).ReadMIMEHeader()
	if errRetrieveContextCacheTag != nil {
		return v0RetrieveContextCacheTag, fmt.Errorf("error reading 'RetrieveContextCacheTag' header: %w", errRetrieveContextCacheTag)
	}

	urlRetrieveContextCacheTag := addrRetrieveContextCacheTag.String()
	requestRetrieveContextCacheTag, errRetrieveContextCacheTag := http.NewRequestWithContext(ctx, "GET", urlRetrieveContextCacheTag, http.NoBody)
	if errRetrieveContextCacheTag != nil {
		return v0RetrieveContextCacheTag, fmt.Errorf("error building 'RetrieveContextCacheTag' request: %w", errRetrieveContextCacheTag)
	}

	for kRetrieveContextCacheTag, vvRetrieveContextCacheTag := range mimeHeaderRetrieveContextCacheTag {
		for _, vRetrieveContextCacheTag := range vvRetrieveContextCacheTag {
			requestRetrieveContextCacheTag.Header.Add(kRetrieveContextCacheTag, vRetrieveContextCacheTag)
		}
	}

	startRetrieveContextCacheTag := time.Now()

	if httpClientRetrieveContextCacheTag, okRetrieveContextCacheTag := innerRetrieveContextCacheTag.(interface{ Client() *http.Client }); okRetrieveContextCacheTag {
		httpResponseRetrieveContextCacheTag, errRetrieveContextCacheTag = httpClientRetrieveContextCacheTag.Client().Do(requestRetrieveContextCacheTag)
	} else {
		httpResponseRetrieveContextCacheTag, errRetrieveContextCacheTag = http.DefaultClient.Do(requestRetrieveContextCacheTag)
	}

	if logRetrieveContextCacheTag, okRetrieveContextCacheTag := innerRetrieveContextCacheTag.(interface {
		Log(ctx context.Context, caller string, request *http.Request, response *http.Response, elapse time.Duration)
	}); okRetrieveContextCacheTag {
		logRetrieveContextCacheTag.Log(ctx, "RetrieveContextCacheTag", requestRetrieveContextCacheTag, httpResponseRetrieveContextCacheTag, time.Since(startRetrieveContextCacheTag))
	}

	if errRetrieveContextCacheTag != nil {
		return v0RetrieveContextCacheTag, fmt.Errorf("error sending 'RetrieveContextCacheTag' request: %w", errRetrieveContextCacheTag)
	}

	if httpResponseRetrieveContextCacheTag.StatusCode < 200 || httpResponseRetrieveContextCacheTag.StatusCode > 299 {
		return v0RetrieveContextCacheTag, __ClientNewResponseError("RetrieveContextCacheTag", httpResponseRetrieveContextCacheTag)
	}

	if errRetrieveContextCacheTag = responseRetrieveContextCacheTag.FromResponse("RetrieveContextCacheTag", httpResponseRetrieveContextCacheTag); errRetrieveContextCacheTag != nil {
		return v0RetrieveContextCacheTag, fmt.Errorf("error converting 'RetrieveContextCacheTag' response: %w", errRetrieveContextCacheTag)
	}

	addrRetrieveContextCacheTag.Reset()
	headerRetrieveContextCacheTag.Reset()

	if errRetrieveContextCacheTag = responseRetrieveContextCacheTag.Err(); errRetrieveContextCacheTag != nil {
		return v0RetrieveContextCacheTag, fmt.Errorf("error returned from 'RetrieveContextCacheTag' response: %w", errRetrieveContextCacheTag)
	}

	if errRetrieveContextCacheTag = responseRetrieveContextCacheTag.ScanValues(v0RetrieveContextCacheTag); errRetrieveContextCacheTag != nil {
		return v0RetrieveContextCacheTag, fmt.Errorf("error scanning value from 'RetrieveContextCacheTag' response: %w", errRetrieveContextCacheTag)
	}

	return v0RetrieveContextCacheTag, nil
}

func (__imp *implClient[C]) UploadFile(ctx context.Context, request *UploadFileRequest) (*File, error) {
	var innerUploadFile any = __imp.Inner()

	addrUploadFile := __ClientGetBuffer()
	defer __ClientPutBuffer(addrUploadFile)
	defer addrUploadFile.Reset()

	headerUploadFile := __ClientGetBuffer()
	defer __ClientPutBuffer(headerUploadFile)
	defer headerUploadFile.Reset()

	var (
		v0UploadFile           = new(File)
		errUploadFile          error
		httpResponseUploadFile *http.Response
		responseUploadFile     ClientResponseInterface = __imp.response()
	)

	if errUploadFile = addrTmplUploadFile.Execute(addrUploadFile, map[string]any{
		"Client":  __imp.Inner(),
		"ctx":     ctx,
		"request": request,
	}); errUploadFile != nil {
		return v0UploadFile, fmt.Errorf("error building 'UploadFile' url: %w", errUploadFile)
	}

	if errUploadFile = headerTmplUploadFile.Execute(headerUploadFile, map[string]any{
		"Client":  __imp.Inner(),
		"ctx":     ctx,
		"request": request,
	}); errUploadFile != nil {
		return v0UploadFile, fmt.Errorf("error building 'UploadFile' header: %w", errUploadFile)
	}
	bufReaderUploadFile := bufio.NewReader(headerUploadFile)
	mimeHeaderUploadFile, errUploadFile := textproto.NewReader(bufReaderUploadFile).ReadMIMEHeader()
	if errUploadFile != nil {
		return v0UploadFile, fmt.Errorf("error reading 'UploadFile' header: %w", errUploadFile)
	}

	urlUploadFile := addrUploadFile.String()
	requestUploadFile, errUploadFile := http.NewRequestWithContext(ctx, "POST", urlUploadFile, request)
	if errUploadFile != nil {
		return v0UploadFile, fmt.Errorf("error building 'UploadFile' request: %w", errUploadFile)
	}

	for kUploadFile, vvUploadFile := range mimeHeaderUploadFile {
		for _, vUploadFile := range vvUploadFile {
			requestUploadFile.Header.Add(kUploadFile, vUploadFile)
		}
	}

	startUploadFile := time.Now()

	if httpClientUploadFile, okUploadFile := innerUploadFile.(interface{ Client() *http.Client }); okUploadFile {
		httpResponseUploadFile, errUploadFile = httpClientUploadFile.Client().Do(requestUploadFile)
	} else {
		httpResponseUploadFile, errUploadFile = http.DefaultClient.Do(requestUploadFile)
	}

	if logUploadFile, okUploadFile := innerUploadFile.(interface {
		Log(ctx context.Context, caller string, request *http.Request, response *http.Response, elapse time.Duration)
	}); okUploadFile {
		logUploadFile.Log(ctx, "UploadFile", requestUploadFile, httpResponseUploadFile, time.Since(startUploadFile))
	}

	if errUploadFile != nil {
		return v0UploadFile, fmt.Errorf("error sending 'UploadFile' request: %w", errUploadFile)
	}

	if httpResponseUploadFile.StatusCode < 200 || httpResponseUploadFile.StatusCode > 299 {
		return v0UploadFile, __ClientNewResponseError("UploadFile", httpResponseUploadFile)
	}

	if errUploadFile = responseUploadFile.FromResponse("UploadFile", httpResponseUploadFile); errUploadFile != nil {
		return v0UploadFile, fmt.Errorf("error converting 'UploadFile' response: %w", errUploadFile)
	}

	addrUploadFile.Reset()
	headerUploadFile.Reset()

	if errUploadFile = responseUploadFile.Err(); errUploadFile != nil {
		return v0UploadFile, fmt.Errorf("error returned from 'UploadFile' response: %w", errUploadFile)
	}

	if errUploadFile = responseUploadFile.ScanValues(v0UploadFile); errUploadFile != nil {
		return v0UploadFile, fmt.Errorf("error scanning value from 'UploadFile' response: %w", errUploadFile)
	}

	return v0UploadFile, nil
}

func (__imp *implClient[C]) ListFiles(ctx context.Context) (*Files, error) {
	var innerListFiles any = __imp.Inner()

	addrListFiles := __ClientGetBuffer()
	defer __ClientPutBuffer(addrListFiles)
	defer addrListFiles.Reset()

	headerListFiles := __ClientGetBuffer()
	defer __ClientPutBuffer(headerListFiles)
	defer headerListFiles.Reset()

	var (
		v0ListFiles           = new(Files)
		errListFiles          error
		httpResponseListFiles *http.Response
		responseListFiles     ClientResponseInterface = __imp.response()
	)

	if errListFiles = addrTmplListFiles.Execute(addrListFiles, map[string]any{
		"Client": __imp.Inner(),
		"ctx":    ctx,
	}); errListFiles != nil {
		return v0ListFiles, fmt.Errorf("error building 'ListFiles' url: %w", errListFiles)
	}

	if errListFiles = headerTmplListFiles.Execute(headerListFiles, map[string]any{
		"Client": __imp.Inner(),
		"ctx":    ctx,
	}); errListFiles != nil {
		return v0ListFiles, fmt.Errorf("error building 'ListFiles' header: %w", errListFiles)
	}
	bufReaderListFiles := bufio.NewReader(headerListFiles)
	mimeHeaderListFiles, errListFiles := textproto.NewReader(bufReaderListFiles).ReadMIMEHeader()
	if errListFiles != nil {
		return v0ListFiles, fmt.Errorf("error reading 'ListFiles' header: %w", errListFiles)
	}

	urlListFiles := addrListFiles.String()
	requestListFiles, errListFiles := http.NewRequestWithContext(ctx, "GET", urlListFiles, http.NoBody)
	if errListFiles != nil {
		return v0ListFiles, fmt.Errorf("error building 'ListFiles' request: %w", errListFiles)
	}

	for kListFiles, vvListFiles := range mimeHeaderListFiles {
		for _, vListFiles := range vvListFiles {
			requestListFiles.Header.Add(kListFiles, vListFiles)
		}
	}

	startListFiles := time.Now()

	if httpClientListFiles, okListFiles := innerListFiles.(interface{ Client() *http.Client }); okListFiles {
		httpResponseListFiles, errListFiles = httpClientListFiles.Client().Do(requestListFiles)
	} else {
		httpResponseListFiles, errListFiles = http.DefaultClient.Do(requestListFiles)
	}

	if logListFiles, okListFiles := innerListFiles.(interface {
		Log(ctx context.Context, caller string, request *http.Request, response *http.Response, elapse time.Duration)
	}); okListFiles {
		logListFiles.Log(ctx, "ListFiles", requestListFiles, httpResponseListFiles, time.Since(startListFiles))
	}

	if errListFiles != nil {
		return v0ListFiles, fmt.Errorf("error sending 'ListFiles' request: %w", errListFiles)
	}

	if httpResponseListFiles.StatusCode < 200 || httpResponseListFiles.StatusCode > 299 {
		return v0ListFiles, __ClientNewResponseError("ListFiles", httpResponseListFiles)
	}

	if errListFiles = responseListFiles.FromResponse("ListFiles", httpResponseListFiles); errListFiles != nil {
		return v0ListFiles, fmt.Errorf("error converting 'ListFiles' response: %w", errListFiles)
	}

	addrListFiles.Reset()
	headerListFiles.Reset()

	if errListFiles = responseListFiles.Err(); errListFiles != nil {
		return v0ListFiles, fmt.Errorf("error returned from 'ListFiles' response: %w", errListFiles)
	}

	if errListFiles = responseListFiles.ScanValues(v0ListFiles); errListFiles != nil {
		return v0ListFiles, fmt.Errorf("error scanning value from 'ListFiles' response: %w", errListFiles)
	}

	return v0ListFiles, nil
}

func (__imp *implClient[C]) DeleteFile(ctx context.Context, fileID string) error {
	var innerDeleteFile any = __imp.Inner()

	addrDeleteFile := __ClientGetBuffer()
	defer __ClientPutBuffer(addrDeleteFile)
	defer addrDeleteFile.Reset()

	headerDeleteFile := __ClientGetBuffer()
	defer __ClientPutBuffer(headerDeleteFile)
	defer headerDeleteFile.Reset()

	var (
		errDeleteFile          error
		httpResponseDeleteFile *http.Response
		responseDeleteFile     ClientResponseInterface = __imp.response()
	)

	if errDeleteFile = addrTmplDeleteFile.Execute(addrDeleteFile, map[string]any{
		"Client": __imp.Inner(),
		"ctx":    ctx,
		"fileID": fileID,
	}); errDeleteFile != nil {
		return fmt.Errorf("error building 'DeleteFile' url: %w", errDeleteFile)
	}

	if errDeleteFile = headerTmplDeleteFile.Execute(headerDeleteFile, map[string]any{
		"Client": __imp.Inner(),
		"ctx":    ctx,
		"fileID": fileID,
	}); errDeleteFile != nil {
		return fmt.Errorf("error building 'DeleteFile' header: %w", errDeleteFile)
	}
	bufReaderDeleteFile := bufio.NewReader(headerDeleteFile)
	mimeHeaderDeleteFile, errDeleteFile := textproto.NewReader(bufReaderDeleteFile).ReadMIMEHeader()
	if errDeleteFile != nil {
		return fmt.Errorf("error reading 'DeleteFile' header: %w", errDeleteFile)
	}

	urlDeleteFile := addrDeleteFile.String()
	requestDeleteFile, errDeleteFile := http.NewRequestWithContext(ctx, "DELETE", urlDeleteFile, http.NoBody)
	if errDeleteFile != nil {
		return fmt.Errorf("error building 'DeleteFile' request: %w", errDeleteFile)
	}

	for kDeleteFile, vvDeleteFile := range mimeHeaderDeleteFile {
		for _, vDeleteFile := range vvDeleteFile {
			requestDeleteFile.Header.Add(kDeleteFile, vDeleteFile)
		}
	}

	startDeleteFile := time.Now()

	if httpClientDeleteFile, okDeleteFile := innerDeleteFile.(interface{ Client() *http.Client }); okDeleteFile {
		httpResponseDeleteFile, errDeleteFile = httpClientDeleteFile.Client().Do(requestDeleteFile)
	} else {
		httpResponseDeleteFile, errDeleteFile = http.DefaultClient.Do(requestDeleteFile)
	}

	if logDeleteFile, okDeleteFile := innerDeleteFile.(interface {
		Log(ctx context.Context, caller string, request *http.Request, response *http.Response, elapse time.Duration)
	}); okDeleteFile {
		logDeleteFile.Log(ctx, "DeleteFile", requestDeleteFile, httpResponseDeleteFile, time.Since(startDeleteFile))
	}

	if errDeleteFile != nil {
		return fmt.Errorf("error sending 'DeleteFile' request: %w", errDeleteFile)
	}

	if httpResponseDeleteFile.StatusCode < 200 || httpResponseDeleteFile.StatusCode > 299 {
		return __ClientNewResponseError("DeleteFile", httpResponseDeleteFile)
	}

	if errDeleteFile = responseDeleteFile.FromResponse("DeleteFile", httpResponseDeleteFile); errDeleteFile != nil {
		return fmt.Errorf("error converting 'DeleteFile' response: %w", errDeleteFile)
	}

	addrDeleteFile.Reset()
	headerDeleteFile.Reset()

	if errDeleteFile = responseDeleteFile.Err(); errDeleteFile != nil {
		return fmt.Errorf("error returned from 'DeleteFile' response: %w", errDeleteFile)
	}

	if errDeleteFile = responseDeleteFile.ScanValues(); errDeleteFile != nil {
		return fmt.Errorf("error scanning value from 'DeleteFile' response: %w", errDeleteFile)
	}

	return nil
}

func (__imp *implClient[C]) RetrieveFileContent(ctx context.Context, fileID string) ([]byte, error) {
	var innerRetrieveFileContent any = __imp.Inner()

	addrRetrieveFileContent := __ClientGetBuffer()
	defer __ClientPutBuffer(addrRetrieveFileContent)
	defer addrRetrieveFileContent.Reset()

	headerRetrieveFileContent := __ClientGetBuffer()
	defer __ClientPutBuffer(headerRetrieveFileContent)
	defer headerRetrieveFileContent.Reset()

	var (
		v0RetrieveFileContent           = __ClientNew[[]byte]()
		errRetrieveFileContent          error
		httpResponseRetrieveFileContent *http.Response
		responseRetrieveFileContent     ClientResponseInterface = __imp.response()
	)

	if errRetrieveFileContent = addrTmplRetrieveFileContent.Execute(addrRetrieveFileContent, map[string]any{
		"Client": __imp.Inner(),
		"ctx":    ctx,
		"fileID": fileID,
	}); errRetrieveFileContent != nil {
		return v0RetrieveFileContent, fmt.Errorf("error building 'RetrieveFileContent' url: %w", errRetrieveFileContent)
	}

	if errRetrieveFileContent = headerTmplRetrieveFileContent.Execute(headerRetrieveFileContent, map[string]any{
		"Client": __imp.Inner(),
		"ctx":    ctx,
		"fileID": fileID,
	}); errRetrieveFileContent != nil {
		return v0RetrieveFileContent, fmt.Errorf("error building 'RetrieveFileContent' header: %w", errRetrieveFileContent)
	}
	bufReaderRetrieveFileContent := bufio.NewReader(headerRetrieveFileContent)
	mimeHeaderRetrieveFileContent, errRetrieveFileContent := textproto.NewReader(bufReaderRetrieveFileContent).ReadMIMEHeader()
	if errRetrieveFileContent != nil {
		return v0RetrieveFileContent, fmt.Errorf("error reading 'RetrieveFileContent' header: %w", errRetrieveFileContent)
	}

	urlRetrieveFileContent := addrRetrieveFileContent.String()
	requestRetrieveFileContent, errRetrieveFileContent := http.NewRequestWithContext(ctx, "GET", urlRetrieveFileContent, http.NoBody)
	if errRetrieveFileContent != nil {
		return v0RetrieveFileContent, fmt.Errorf("error building 'RetrieveFileContent' request: %w", errRetrieveFileContent)
	}

	for kRetrieveFileContent, vvRetrieveFileContent := range mimeHeaderRetrieveFileContent {
		for _, vRetrieveFileContent := range vvRetrieveFileContent {
			requestRetrieveFileContent.Header.Add(kRetrieveFileContent, vRetrieveFileContent)
		}
	}

	startRetrieveFileContent := time.Now()

	if httpClientRetrieveFileContent, okRetrieveFileContent := innerRetrieveFileContent.(interface{ Client() *http.Client }); okRetrieveFileContent {
		httpResponseRetrieveFileContent, errRetrieveFileContent = httpClientRetrieveFileContent.Client().Do(requestRetrieveFileContent)
	} else {
		httpResponseRetrieveFileContent, errRetrieveFileContent = http.DefaultClient.Do(requestRetrieveFileContent)
	}

	if logRetrieveFileContent, okRetrieveFileContent := innerRetrieveFileContent.(interface {
		Log(ctx context.Context, caller string, request *http.Request, response *http.Response, elapse time.Duration)
	}); okRetrieveFileContent {
		logRetrieveFileContent.Log(ctx, "RetrieveFileContent", requestRetrieveFileContent, httpResponseRetrieveFileContent, time.Since(startRetrieveFileContent))
	}

	if errRetrieveFileContent != nil {
		return v0RetrieveFileContent, fmt.Errorf("error sending 'RetrieveFileContent' request: %w", errRetrieveFileContent)
	}

	if httpResponseRetrieveFileContent.StatusCode < 200 || httpResponseRetrieveFileContent.StatusCode > 299 {
		return v0RetrieveFileContent, __ClientNewResponseError("RetrieveFileContent", httpResponseRetrieveFileContent)
	}

	if errRetrieveFileContent = responseRetrieveFileContent.FromResponse("RetrieveFileContent", httpResponseRetrieveFileContent); errRetrieveFileContent != nil {
		return v0RetrieveFileContent, fmt.Errorf("error converting 'RetrieveFileContent' response: %w", errRetrieveFileContent)
	}

	addrRetrieveFileContent.Reset()
	headerRetrieveFileContent.Reset()

	if errRetrieveFileContent = responseRetrieveFileContent.Err(); errRetrieveFileContent != nil {
		return v0RetrieveFileContent, fmt.Errorf("error returned from 'RetrieveFileContent' response: %w", errRetrieveFileContent)
	}

	if errRetrieveFileContent = responseRetrieveFileContent.ScanValues(&v0RetrieveFileContent); errRetrieveFileContent != nil {
		return v0RetrieveFileContent, fmt.Errorf("error scanning value from 'RetrieveFileContent' response: %w", errRetrieveFileContent)
	}

	return v0RetrieveFileContent, nil
}

func (__imp *implClient[C]) Inner() C {
	return __imp.__Client
}

func (*implClient[C]) response() *ResponseHandler {
	return new(ResponseHandler)
}

var __ClientBufferPool = sync.Pool{
	New: func() any {
		return new(bytes.Buffer)
	},
}

func __ClientGetBuffer() *bytes.Buffer {
	return __ClientBufferPool.Get().(*bytes.Buffer)
}

func __ClientPutBuffer(buffer *bytes.Buffer) {
	__ClientBufferPool.Put(buffer)
}

type ClientResponseInterface interface {
	Err() error
	ScanValues(...any) error
	FromResponse(string, *http.Response) error
	Break() bool
}

func __ClientNewType(typ reflect.Type) reflect.Value {
	switch typ.Kind() {
	case reflect.Slice:
		return reflect.MakeSlice(typ, 0, 0)
	case reflect.Map:
		return reflect.MakeMap(typ)
	case reflect.Chan:
		return reflect.MakeChan(typ, 0)
	case reflect.Func:
		return reflect.MakeFunc(typ, func(_ []reflect.Value) (results []reflect.Value) {
			results = make([]reflect.Value, typ.NumOut())
			for i := 0; i < typ.NumOut(); i++ {
				results[i] = __ClientNewType(typ.Out(i))
			}
			return results
		})
	case reflect.Pointer:
		return reflect.New(typ.Elem())
	default:
		return reflect.Zero(typ)
	}
}

func __ClientNew[T any]() (v T) {
	val := reflect.ValueOf(&v).Elem()
	switch val.Kind() {
	case reflect.Slice, reflect.Map, reflect.Chan, reflect.Func, reflect.Pointer:
		val.Set(__ClientNewType(val.Type()))
	}
	return v
}

// ClientResponseErrorInterface represents future Response error interface which would
// be used in next major version of defc, who may cause breaking changes.
//
// generated with --features=api/future
type ClientResponseErrorInterface interface {
	error
	Response() *http.Response
}

func __ClientNewResponseError(caller string, response *http.Response) ClientResponseErrorInterface {
	return &__ClientImplResponseError{
		caller:   caller,
		response: response,
	}
}

type __ClientImplResponseError struct {
	caller   string
	response *http.Response
}

func (e *__ClientImplResponseError) Error() string {
	return fmt.Sprintf("response status code %d for '%s'", e.response.StatusCode, e.caller)
}

func (e *__ClientImplResponseError) Response() *http.Response {
	return e.response
}
