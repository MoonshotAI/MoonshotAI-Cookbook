//go:build context_cache

// Code generated by defc, DO NOT EDIT.

package main

import (
	"bytes"
	"context"
	"database/sql"
	"database/sql/driver"
	"errors"
	"fmt"
	"reflect"
	"strconv"
	"strings"
	"sync"
	"text/template"

	"github.com/jmoiron/sqlx"
)

func NewContextCacheManager(drv string, dsn string) ContextCacheManager {
	return &implContextCacheManager{
		__core: sqlx.MustOpen(drv, dsn),
	}
}

func NewContextCacheManagerFromDB(core *sqlx.DB) ContextCacheManager {
	return &implContextCacheManager{
		__core: core,
	}
}

func NewContextCacheManagerFromCore(core ContextCacheManagerCoreInterface) ContextCacheManager {
	return &implContextCacheManager{
		__core: core,
	}
}

type implContextCacheManager struct {
	__withTx bool
	__core   ContextCacheManagerCoreInterface
}

func (__imp *implContextCacheManager) SetWithTx(withTx bool) {
	__imp.__withTx = withTx
}

func (__imp *implContextCacheManager) SetCore(core any) {
	__imp.__core = core.(ContextCacheManagerCoreInterface)
}

func (__imp *implContextCacheManager) Clone() ContextCacheManager {
	var ()
	return &implContextCacheManager{
		__withTx: __imp.__withTx,
		__core:   __imp.__core,
	}
}

func (__imp *implContextCacheManager) Close() error {
	if closer, ok := __imp.__core.(interface{ Close() error }); ok {
		return closer.Close()
	}
	return nil
}

var (
	_ = (*template.Template)(nil)

	__ContextCacheManagerBaseTemplate = template.Must(template.New("ContextCacheManagerBaseTemplate").Funcs(template.FuncMap{"bindvars": __ContextCacheManagerBindVars}).Parse(""))

	sqlTmplcreateTable = template.Must(__ContextCacheManagerBaseTemplate.New("createTable").Parse("create table if not exists context_cache ( id    integer not null constraint context_cache_pk primary key autoincrement, key            text    not null, cache_id       text    not null, cache_status   text    not null, cache_messages text    not null );\r\n"))
	sqlTmplSet         = template.Must(__ContextCacheManagerBaseTemplate.New("Set").Parse("delete from context_cache where key = {{ $.args.Add $.key }}; insert into context_cache ( key, cache_id, cache_status, cache_messages ) values ( {{ $.args.Add $.key }}, {{ $.args.Add $.cache.ID }}, {{ $.args.Add $.cache.Status }}, {{ $.args.Add $.cache.Messages }} );\r\n"))
)

func (__imp *implContextCacheManager) createTable(ctx context.Context) error {
	var (
		errcreateTable     error
		argListcreateTable = make(__ContextCacheManagerArguments, 0, 8)
	)

	argListcreateTable = __ContextCacheManagerArguments{}

	sqlcreateTable := __ContextCacheManagerGetBuffer()
	defer __ContextCacheManagerPutBuffer(sqlcreateTable)
	defer sqlcreateTable.Reset()

	if errcreateTable = sqlTmplcreateTable.Execute(sqlcreateTable, map[string]any{
		"ctx": ctx,
	}); errcreateTable != nil {
		return fmt.Errorf("error executing %s template: %w", strconv.Quote("createTable"), errcreateTable)
	}

	querycreateTable := sqlcreateTable.String()

	txcreateTable, errcreateTable := __imp.__core.BeginTxx(ctx, nil)
	if errcreateTable != nil {
		return fmt.Errorf("error creating %s transaction: %w", strconv.Quote("createTable"), errcreateTable)
	}
	if !__imp.__withTx {
		defer txcreateTable.Rollback()
	}

	offsetcreateTable := 0
	argscreateTable := __ContextCacheManagerMergeArgs(argListcreateTable...)

	sqlSlicecreateTable := __ContextCacheManagerSplit(querycreateTable, ";")
	for indexcreateTable, splitSqlcreateTable := range sqlSlicecreateTable {
		_ = indexcreateTable

		countcreateTable := __ContextCacheManagerCount(splitSqlcreateTable, "?")

		_, errcreateTable = txcreateTable.ExecContext(ctx, splitSqlcreateTable, argscreateTable[offsetcreateTable:offsetcreateTable+countcreateTable]...)

		if errcreateTable != nil {
			return fmt.Errorf("error executing %s sql: \n\n%s\n\n%w", strconv.Quote("createTable"), splitSqlcreateTable, errcreateTable)
		}

		offsetcreateTable += countcreateTable
	}

	if !__imp.__withTx {
		if errcreateTable := txcreateTable.Commit(); errcreateTable != nil {
			return fmt.Errorf("error committing %s transaction: %w", strconv.Quote("createTable"), errcreateTable)
		}
	}

	return nil
}

func (__imp *implContextCacheManager) Set(ctx context.Context, key string, cache *ContextCache) error {
	var (
		errSet     error
		argListSet = make(__ContextCacheManagerArguments, 0, 8)
	)

	sqlSet := __ContextCacheManagerGetBuffer()
	defer __ContextCacheManagerPutBuffer(sqlSet)
	defer sqlSet.Reset()

	if errSet = sqlTmplSet.Execute(sqlSet, map[string]any{
		"args":  &argListSet,
		"ctx":   ctx,
		"key":   key,
		"cache": cache,
	}); errSet != nil {
		return fmt.Errorf("error executing %s template: %w", strconv.Quote("Set"), errSet)
	}

	querySet := sqlSet.String()

	txSet, errSet := __imp.__core.BeginTxx(ctx, nil)
	if errSet != nil {
		return fmt.Errorf("error creating %s transaction: %w", strconv.Quote("Set"), errSet)
	}
	if !__imp.__withTx {
		defer txSet.Rollback()
	}

	offsetSet := 0
	argsSet := __ContextCacheManagerMergeArgs(argListSet...)

	sqlSliceSet := __ContextCacheManagerSplit(querySet, ";")
	for indexSet, splitSqlSet := range sqlSliceSet {
		_ = indexSet

		countSet := __ContextCacheManagerCount(splitSqlSet, "?")

		_, errSet = txSet.ExecContext(ctx, splitSqlSet, argsSet[offsetSet:offsetSet+countSet]...)

		if errSet != nil {
			return fmt.Errorf("error executing %s sql: \n\n%s\n\n%w", strconv.Quote("Set"), splitSqlSet, errSet)
		}

		offsetSet += countSet
	}

	if !__imp.__withTx {
		if errSet := txSet.Commit(); errSet != nil {
			return fmt.Errorf("error committing %s transaction: %w", strconv.Quote("Set"), errSet)
		}
	}

	return nil
}

func (__imp *implContextCacheManager) Get(ctx context.Context, key string) (*ContextCache, error) {
	var (
		v0Get      = new(ContextCache)
		errGet     error
		argListGet = make(__ContextCacheManagerArguments, 0, 8)
	)

	argListGet = __ContextCacheManagerArguments{
		key,
	}

	queryGet := "select cache_id, cache_status, cache_messages from context_cache where key = ?;\r\n"

	txGet, errGet := __imp.__core.BeginTxx(ctx, nil)
	if errGet != nil {
		return v0Get, fmt.Errorf("error creating %s transaction: %w", strconv.Quote("Get"), errGet)
	}
	if !__imp.__withTx {
		defer txGet.Rollback()
	}

	offsetGet := 0
	argsGet := __ContextCacheManagerMergeArgs(argListGet...)

	sqlSliceGet := __ContextCacheManagerSplit(queryGet, ";")
	for indexGet, splitSqlGet := range sqlSliceGet {
		_ = indexGet

		countGet := __ContextCacheManagerCount(splitSqlGet, "?")

		if indexGet < len(sqlSliceGet)-1 {
			_, errGet = txGet.ExecContext(ctx, splitSqlGet, argsGet[offsetGet:offsetGet+countGet]...)
		} else {
			errGet = txGet.GetContext(ctx, v0Get, splitSqlGet, argsGet[offsetGet:offsetGet+countGet]...)
		}

		if errGet != nil {
			return v0Get, fmt.Errorf("error executing %s sql: \n\n%s\n\n%w", strconv.Quote("Get"), splitSqlGet, errGet)
		}

		offsetGet += countGet
	}

	if !__imp.__withTx {
		if errGet := txGet.Commit(); errGet != nil {
			return v0Get, fmt.Errorf("error committing %s transaction: %w", strconv.Quote("Get"), errGet)
		}
	}

	return v0Get, nil
}

type ContextCacheManagerCoreInterface interface {
	Beginx() (*sqlx.Tx, error)
	BeginTxx(ctx context.Context, opts *sql.TxOptions) (*sqlx.Tx, error)
	Exec(query string, args ...interface{}) (sql.Result, error)
	ExecContext(ctx context.Context, query string, args ...interface{}) (sql.Result, error)
	Get(dest interface{}, query string, args ...interface{}) error
	GetContext(ctx context.Context, dest interface{}, query string, args ...interface{}) error
	Select(dest interface{}, query string, args ...interface{}) error
	SelectContext(ctx context.Context, dest interface{}, query string, args ...interface{}) error
}

var __ContextCacheManagerBufferPool = sync.Pool{
	New: func() any {
		return new(bytes.Buffer)
	},
}

func __ContextCacheManagerGetBuffer() *bytes.Buffer {
	return __ContextCacheManagerBufferPool.Get().(*bytes.Buffer)
}

func __ContextCacheManagerPutBuffer(buffer *bytes.Buffer) {
	__ContextCacheManagerBufferPool.Put(buffer)
}

type (
	__ContextCacheManagerNotAnArg interface {
		NotAnArg()
	}

	__ContextCacheManagerToArgs interface {
		ToArgs() []any
	}

	__ContextCacheManagerToNamedArgs interface {
		ToNamedArgs() map[string]any
	}
)

var __ContextCacheManagerBytesType = reflect.TypeOf([]byte{})

func __ContextCacheManagerMergeArgs(args ...any) []any {
	dst := make([]any, 0, len(args))
	for _, arg := range args {
		rv := reflect.ValueOf(arg)
		if _, notAnArg := arg.(__ContextCacheManagerNotAnArg); notAnArg {
			continue
		} else if toArgs, ok := arg.(__ContextCacheManagerToArgs); ok {
			dst = append(dst, __ContextCacheManagerMergeArgs(toArgs.ToArgs()...)...)
		} else if _, ok = arg.(driver.Valuer); ok {
			dst = append(dst, arg)
		} else if (rv.Kind() == reflect.Slice && !rv.Type().AssignableTo(__ContextCacheManagerBytesType)) ||
			rv.Kind() == reflect.Array {
			for i := 0; i < rv.Len(); i++ {
				dst = append(dst, __ContextCacheManagerMergeArgs(rv.Index(i).Interface())...)
			}
		} else {
			dst = append(dst, arg)
		}
	}
	return dst
}

func __ContextCacheManagerMergeNamedArgs(argsMap map[string]any) map[string]any {
	namedMap := make(map[string]any, len(argsMap))
	for name, arg := range argsMap {
		rv := reflect.ValueOf(arg)
		if _, notAnArg := arg.(__ContextCacheManagerNotAnArg); notAnArg {
			continue
		} else if toNamedArgs, ok := arg.(__ContextCacheManagerToNamedArgs); ok {
			for k, v := range toNamedArgs.ToNamedArgs() {
				namedMap[k] = v
			}
		} else if _, ok = arg.(driver.Valuer); ok {
			namedMap[name] = arg
		} else if _, ok = arg.(__ContextCacheManagerToArgs); ok {
			namedMap[name] = arg
		} else if rv.Kind() == reflect.Map {
			iter := rv.MapRange()
			for iter.Next() {
				k, v := iter.Key(), iter.Value()
				if k.Kind() == reflect.String {
					namedMap[k.String()] = v.Interface()
				}
			}
		} else if rv.Kind() == reflect.Struct ||
			(rv.Kind() == reflect.Pointer && rv.Elem().Kind() == reflect.Struct) {
			rv = reflect.Indirect(rv)
			rt := rv.Type()
			for i := 0; i < rt.NumField(); i++ {
				if sf := rt.Field(i); sf.Anonymous {
					sft := sf.Type
					if sft.Kind() == reflect.Pointer {
						sft = sft.Elem()
					}
					for j := 0; j < sft.NumField(); j++ {
						if tag, exists := sft.Field(j).Tag.Lookup("db"); exists {
							for pos, char := range tag {
								if !(('0' <= char && char <= '9') || ('a' <= char && char <= 'z') || ('A' <= char && char <= 'Z') || char == '_') {
									tag = tag[:pos]
									break
								}
							}
							namedMap[tag] = rv.FieldByIndex([]int{i, j}).Interface()
						}
					}
				} else if tag, exists := sf.Tag.Lookup("db"); exists {
					for pos, char := range tag {
						if !(('0' <= char && char <= '9') || ('a' <= char && char <= 'z') || ('A' <= char && char <= 'Z') || char == '_') {
							tag = tag[:pos]
							break
						}
					}
					namedMap[tag] = rv.Field(i).Interface()
				}
			}
		} else {
			namedMap[name] = arg
		}
	}
	return namedMap
}

func __ContextCacheManagerBindVars(data any) string {
	var n int
	switch rv := reflect.ValueOf(data); rv.Kind() {
	case reflect.Int, reflect.Int8, reflect.Int16, reflect.Int32, reflect.Int64:
		n = int(rv.Int())
	case reflect.Uint, reflect.Uint8, reflect.Uint16, reflect.Uint32, reflect.Uint64:
		n = int(rv.Uint())
	case reflect.Slice:
		if rv.Type().AssignableTo(__ContextCacheManagerBytesType) {
			n = 1
		} else {
			n = rv.Len()
		}
	default:
		n = 1
	}

	bindVars := make([]string, n)
	for i := 0; i < n; i++ {
		bindVars[i] = "?"
	}

	return strings.Join(bindVars, ", ")
}

func __ContextCacheManagerIn[S ~[]any](query string, args S) (string, S, error) {
	tokens := __ContextCacheManagerSplitTokens(query)
	targetArgs := make(S, 0, len(args))
	targetQuery := make([]string, 0, len(tokens))
	n := 0
	for _, token := range tokens {
		switch token {
		case "?":
			if n >= len(args) {
				return "", nil, errors.New("number of BindVars exceeds arguments")
			}
			nested := __ContextCacheManagerMergeArgs(args[n])
			if len(nested) == 0 {
				return "", nil, errors.New("empty slice passed to 'in' query")
			}
			targetArgs = append(targetArgs, nested...)
			targetQuery = append(targetQuery, __ContextCacheManagerBindVars(len(nested)))
			n++
		default:
			targetQuery = append(targetQuery, token)
		}
	}
	if n < len(args) {
		return "", nil, errors.New("number of bindVars less than number arguments")
	}
	return strings.Join(targetQuery, " "), targetArgs, nil
}

type __ContextCacheManagerArguments []any

func (arguments *__ContextCacheManagerArguments) Add(argument any) string {
	merged := __ContextCacheManagerMergeArgs(argument)
	*arguments = append(*arguments, merged...)
	return __ContextCacheManagerBindVars(len(merged))
}

func __ContextCacheManagerCount(sql string, ch string) (n int) {
	tokens := __ContextCacheManagerSplitTokens(sql)
	for _, token := range tokens {
		if token == ch {
			n++
		}
	}
	return n
}

func __ContextCacheManagerSplit(sql string, sep string) (group []string) {
	tokens := __ContextCacheManagerSplitTokens(sql)
	group = make([]string, 0, len(tokens))
	last := 0
	for i, token := range tokens {
		if token == sep || i+1 == len(tokens) {
			if joint := strings.Join(tokens[last:i+1], " "); len(strings.Trim(joint, sep)) > 0 {
				group = append(group, joint)
			}
			last = i + 1
		}
	}
	return group
}

func __ContextCacheManagerSplitTokens(line string) (tokens []string) {
	var (
		singleQuoted bool
		doubleQuoted bool
		arg          []byte
	)

	for i := 0; i < len(line); i++ {
		switch ch := line[i]; ch {
		case ';', '?':
			if doubleQuoted || singleQuoted {
				arg = append(arg, ch)
			} else {
				if len(arg) > 0 {
					tokens = append(tokens, string(arg))
				}
				tokens = append(tokens, string(ch))
				arg = arg[:0]
			}
		case ' ', '\t', '\n', '\r':
			if doubleQuoted || singleQuoted {
				arg = append(arg, ch)
			} else if len(arg) > 0 {
				tokens = append(tokens, string(arg))
				arg = arg[:0]
			}
		case '"':
			if !(i > 0 && line[i-1] == '\\' || singleQuoted) {
				doubleQuoted = !doubleQuoted
			}
			arg = append(arg, ch)
		case '\'':
			if !(i > 0 && line[i-1] == '\\' || doubleQuoted) {
				singleQuoted = !singleQuoted
			}
			arg = append(arg, ch)
		default:
			arg = append(arg, ch)
		}
	}

	if len(arg) > 0 {
		tokens = append(tokens, string(arg))
	}

	return tokens
}
